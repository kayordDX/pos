/**
 * Generated by orval v8.1.0 üç∫
 * Do not edit manually.
 * Kayord.Pos
 * OpenAPI spec version: v1
 */
import { createMutation, createQuery } from "@tanstack/svelte-query";
import type {
	CreateMutationOptions,
	CreateMutationResult,
	CreateQueryOptions,
	CreateQueryResult,
	DataTag,
	MutationFunction,
	QueryClient,
	QueryFunction,
	QueryKey,
} from "@tanstack/svelte-query";

import type {
	CancelTickerParams,
	CreateChainJobsParams,
	DeleteCronTickerOccurrenceParams,
	DeleteCronTickerParams,
	DeleteTimeTickerParams,
	GetCronTickerOccurrencesPaginatedParams,
	GetCronTickersByIdGraphDataRangeParams,
	GetCronTickersGraphDataRangeParams,
	GetCronTickersPaginatedParams,
	GetTickerRequestParams,
	GetTimeTickersGraphDataRangeParams,
	GetTimeTickersPaginatedParams,
	RunCronTickerOnDemandParams,
	UpdateCronTickerParams,
	UpdateTimeTickerParams,
} from "./api.schemas";

import { customInstance } from "../mutator/customInstance.svelte";
import type { ErrorType, BodyType } from "../mutator/customInstance.svelte";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export const getGetAuthInfoUrl = () => {
	return `/api/auth/info`;
};

export const getAuthInfo = async (options?: RequestInit): Promise<void> => {
	return customInstance<void>(getGetAuthInfoUrl(), {
		...options,
		method: "GET",
	});
};

export const getGetAuthInfoQueryKey = () => {
	return [`/api/auth/info`] as const;
};

export const getGetAuthInfoQueryOptions = <
	TData = Awaited<ReturnType<typeof getAuthInfo>>,
	TError = ErrorType<unknown>,
>(options?: {
	query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof getAuthInfo>>, TError, TData>>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetAuthInfoQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthInfo>>> = () =>
		getAuthInfo(requestOptions);

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof getAuthInfo>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAuthInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getAuthInfo>>>;
export type GetAuthInfoQueryError = ErrorType<unknown>;

export function createGetAuthInfo<
	TData = Awaited<ReturnType<typeof getAuthInfo>>,
	TError = ErrorType<unknown>,
>(
	options?: () => {
		query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof getAuthInfo>>, TError, TData>>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getGetAuthInfoQueryOptions(options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}

export const getValidateAuthUrl = () => {
	return `/api/auth/validate`;
};

export const validateAuth = async (options?: RequestInit): Promise<void> => {
	return customInstance<void>(getValidateAuthUrl(), {
		...options,
		method: "POST",
	});
};

export const getValidateAuthMutationOptions = <
	TError = ErrorType<unknown>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof validateAuth>>,
		TError,
		void,
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationOptions<Awaited<ReturnType<typeof validateAuth>>, TError, void, TContext> => {
	const mutationKey = ["validateAuth"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<Awaited<ReturnType<typeof validateAuth>>, void> = () => {
		return validateAuth(requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ValidateAuthMutationResult = NonNullable<Awaited<ReturnType<typeof validateAuth>>>;

export type ValidateAuthMutationError = ErrorType<unknown>;

export const createValidateAuth = <TError = ErrorType<unknown>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof validateAuth>>,
			TError,
			void,
			TContext
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<Awaited<ReturnType<typeof validateAuth>>, TError, void, TContext> => {
	return createMutation(() => ({ ...getValidateAuthMutationOptions(options?.()), queryClient }));
};
export const getGetOptionsUrl = () => {
	return `/api/options`;
};

export const getOptions = async (options?: RequestInit): Promise<void> => {
	return customInstance<void>(getGetOptionsUrl(), {
		...options,
		method: "GET",
	});
};

export const getGetOptionsQueryKey = () => {
	return [`/api/options`] as const;
};

export const getGetOptionsQueryOptions = <
	TData = Awaited<ReturnType<typeof getOptions>>,
	TError = ErrorType<unknown>,
>(options?: {
	query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof getOptions>>, TError, TData>>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetOptionsQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getOptions>>> = () =>
		getOptions(requestOptions);

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof getOptions>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetOptionsQueryResult = NonNullable<Awaited<ReturnType<typeof getOptions>>>;
export type GetOptionsQueryError = ErrorType<unknown>;

export function createGetOptions<
	TData = Awaited<ReturnType<typeof getOptions>>,
	TError = ErrorType<unknown>,
>(
	options?: () => {
		query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof getOptions>>, TError, TData>>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getGetOptionsQueryOptions(options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}

export const getGetTimeTickersUrl = () => {
	return `/api/time-tickers`;
};

export const getTimeTickers = async (options?: RequestInit): Promise<void> => {
	return customInstance<void>(getGetTimeTickersUrl(), {
		...options,
		method: "GET",
	});
};

export const getGetTimeTickersQueryKey = () => {
	return [`/api/time-tickers`] as const;
};

export const getGetTimeTickersQueryOptions = <
	TData = Awaited<ReturnType<typeof getTimeTickers>>,
	TError = ErrorType<unknown>,
>(options?: {
	query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof getTimeTickers>>, TError, TData>>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetTimeTickersQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeTickers>>> = () =>
		getTimeTickers(requestOptions);

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof getTimeTickers>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTimeTickersQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeTickers>>>;
export type GetTimeTickersQueryError = ErrorType<unknown>;

export function createGetTimeTickers<
	TData = Awaited<ReturnType<typeof getTimeTickers>>,
	TError = ErrorType<unknown>,
>(
	options?: () => {
		query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof getTimeTickers>>, TError, TData>>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getGetTimeTickersQueryOptions(options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}

export const getGetTimeTickersPaginatedUrl = (params?: GetTimeTickersPaginatedParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/api/time-tickers/paginated?${stringifiedParams}`
		: `/api/time-tickers/paginated`;
};

export const getTimeTickersPaginated = async (
	params?: GetTimeTickersPaginatedParams,
	options?: RequestInit
): Promise<void> => {
	return customInstance<void>(getGetTimeTickersPaginatedUrl(params), {
		...options,
		method: "GET",
	});
};

export const getGetTimeTickersPaginatedQueryKey = (params?: GetTimeTickersPaginatedParams) => {
	return [`/api/time-tickers/paginated`, ...(params ? [params] : [])] as const;
};

export const getGetTimeTickersPaginatedQueryOptions = <
	TData = Awaited<ReturnType<typeof getTimeTickersPaginated>>,
	TError = ErrorType<unknown>,
>(
	params?: GetTimeTickersPaginatedParams,
	options?: {
		query?: Partial<
			CreateQueryOptions<Awaited<ReturnType<typeof getTimeTickersPaginated>>, TError, TData>
		>;
		request?: SecondParameter<typeof customInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetTimeTickersPaginatedQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeTickersPaginated>>> = () =>
		getTimeTickersPaginated(params, requestOptions);

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof getTimeTickersPaginated>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTimeTickersPaginatedQueryResult = NonNullable<
	Awaited<ReturnType<typeof getTimeTickersPaginated>>
>;
export type GetTimeTickersPaginatedQueryError = ErrorType<unknown>;

export function createGetTimeTickersPaginated<
	TData = Awaited<ReturnType<typeof getTimeTickersPaginated>>,
	TError = ErrorType<unknown>,
>(
	params?: () => GetTimeTickersPaginatedParams,
	options?: () => {
		query?: Partial<
			CreateQueryOptions<Awaited<ReturnType<typeof getTimeTickersPaginated>>, TError, TData>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getGetTimeTickersPaginatedQueryOptions(params?.(), options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}

export const getGetTimeTickersGraphDataRangeUrl = (params?: GetTimeTickersGraphDataRangeParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/api/time-tickers/graph-data-range?${stringifiedParams}`
		: `/api/time-tickers/graph-data-range`;
};

export const getTimeTickersGraphDataRange = async (
	params?: GetTimeTickersGraphDataRangeParams,
	options?: RequestInit
): Promise<void> => {
	return customInstance<void>(getGetTimeTickersGraphDataRangeUrl(params), {
		...options,
		method: "GET",
	});
};

export const getGetTimeTickersGraphDataRangeQueryKey = (
	params?: GetTimeTickersGraphDataRangeParams
) => {
	return [`/api/time-tickers/graph-data-range`, ...(params ? [params] : [])] as const;
};

export const getGetTimeTickersGraphDataRangeQueryOptions = <
	TData = Awaited<ReturnType<typeof getTimeTickersGraphDataRange>>,
	TError = ErrorType<unknown>,
>(
	params?: GetTimeTickersGraphDataRangeParams,
	options?: {
		query?: Partial<
			CreateQueryOptions<Awaited<ReturnType<typeof getTimeTickersGraphDataRange>>, TError, TData>
		>;
		request?: SecondParameter<typeof customInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetTimeTickersGraphDataRangeQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeTickersGraphDataRange>>> = () =>
		getTimeTickersGraphDataRange(params, requestOptions);

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof getTimeTickersGraphDataRange>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTimeTickersGraphDataRangeQueryResult = NonNullable<
	Awaited<ReturnType<typeof getTimeTickersGraphDataRange>>
>;
export type GetTimeTickersGraphDataRangeQueryError = ErrorType<unknown>;

export function createGetTimeTickersGraphDataRange<
	TData = Awaited<ReturnType<typeof getTimeTickersGraphDataRange>>,
	TError = ErrorType<unknown>,
>(
	params?: () => GetTimeTickersGraphDataRangeParams,
	options?: () => {
		query?: Partial<
			CreateQueryOptions<Awaited<ReturnType<typeof getTimeTickersGraphDataRange>>, TError, TData>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getGetTimeTickersGraphDataRangeQueryOptions(params?.(), options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}

export const getGetTimeTickersGraphDataUrl = () => {
	return `/api/time-tickers/graph-data`;
};

export const getTimeTickersGraphData = async (options?: RequestInit): Promise<void> => {
	return customInstance<void>(getGetTimeTickersGraphDataUrl(), {
		...options,
		method: "GET",
	});
};

export const getGetTimeTickersGraphDataQueryKey = () => {
	return [`/api/time-tickers/graph-data`] as const;
};

export const getGetTimeTickersGraphDataQueryOptions = <
	TData = Awaited<ReturnType<typeof getTimeTickersGraphData>>,
	TError = ErrorType<unknown>,
>(options?: {
	query?: Partial<
		CreateQueryOptions<Awaited<ReturnType<typeof getTimeTickersGraphData>>, TError, TData>
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetTimeTickersGraphDataQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeTickersGraphData>>> = () =>
		getTimeTickersGraphData(requestOptions);

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof getTimeTickersGraphData>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTimeTickersGraphDataQueryResult = NonNullable<
	Awaited<ReturnType<typeof getTimeTickersGraphData>>
>;
export type GetTimeTickersGraphDataQueryError = ErrorType<unknown>;

export function createGetTimeTickersGraphData<
	TData = Awaited<ReturnType<typeof getTimeTickersGraphData>>,
	TError = ErrorType<unknown>,
>(
	options?: () => {
		query?: Partial<
			CreateQueryOptions<Awaited<ReturnType<typeof getTimeTickersGraphData>>, TError, TData>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getGetTimeTickersGraphDataQueryOptions(options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}

export const getCreateChainJobsUrl = (params?: CreateChainJobsParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/api/time-ticker/add?${stringifiedParams}`
		: `/api/time-ticker/add`;
};

export const createChainJobs = async (
	params?: CreateChainJobsParams,
	options?: RequestInit
): Promise<void> => {
	return customInstance<void>(getCreateChainJobsUrl(params), {
		...options,
		method: "POST",
	});
};

export const getCreateChainJobsMutationOptions = <
	TError = ErrorType<unknown>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof createChainJobs>>,
		TError,
		{ params?: CreateChainJobsParams },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof createChainJobs>>,
	TError,
	{ params?: CreateChainJobsParams },
	TContext
> => {
	const mutationKey = ["createChainJobs"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof createChainJobs>>,
		{ params?: CreateChainJobsParams }
	> = (props) => {
		const { params } = props ?? {};

		return createChainJobs(params, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CreateChainJobsMutationResult = NonNullable<
	Awaited<ReturnType<typeof createChainJobs>>
>;

export type CreateChainJobsMutationError = ErrorType<unknown>;

export const createCreateChainJobs = <TError = ErrorType<unknown>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof createChainJobs>>,
			TError,
			{ params?: CreateChainJobsParams },
			TContext
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof createChainJobs>>,
	TError,
	{ params?: CreateChainJobsParams },
	TContext
> => {
	return createMutation(() => ({ ...getCreateChainJobsMutationOptions(options?.()), queryClient }));
};
export const getUpdateTimeTickerUrl = (params: UpdateTimeTickerParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/api/time-ticker/update?${stringifiedParams}`
		: `/api/time-ticker/update`;
};

export const updateTimeTicker = async (
	params: UpdateTimeTickerParams,
	options?: RequestInit
): Promise<void> => {
	return customInstance<void>(getUpdateTimeTickerUrl(params), {
		...options,
		method: "PUT",
	});
};

export const getUpdateTimeTickerMutationOptions = <
	TError = ErrorType<unknown>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof updateTimeTicker>>,
		TError,
		{ params: UpdateTimeTickerParams },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof updateTimeTicker>>,
	TError,
	{ params: UpdateTimeTickerParams },
	TContext
> => {
	const mutationKey = ["updateTimeTicker"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof updateTimeTicker>>,
		{ params: UpdateTimeTickerParams }
	> = (props) => {
		const { params } = props ?? {};

		return updateTimeTicker(params, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type UpdateTimeTickerMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateTimeTicker>>
>;

export type UpdateTimeTickerMutationError = ErrorType<unknown>;

export const createUpdateTimeTicker = <TError = ErrorType<unknown>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof updateTimeTicker>>,
			TError,
			{ params: UpdateTimeTickerParams },
			TContext
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof updateTimeTicker>>,
	TError,
	{ params: UpdateTimeTickerParams },
	TContext
> => {
	return createMutation(() => ({
		...getUpdateTimeTickerMutationOptions(options?.()),
		queryClient,
	}));
};
export const getDeleteTimeTickerUrl = (params: DeleteTimeTickerParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/api/time-ticker/delete?${stringifiedParams}`
		: `/api/time-ticker/delete`;
};

export const deleteTimeTicker = async (
	params: DeleteTimeTickerParams,
	options?: RequestInit
): Promise<void> => {
	return customInstance<void>(getDeleteTimeTickerUrl(params), {
		...options,
		method: "DELETE",
	});
};

export const getDeleteTimeTickerMutationOptions = <
	TError = ErrorType<unknown>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof deleteTimeTicker>>,
		TError,
		{ params: DeleteTimeTickerParams },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof deleteTimeTicker>>,
	TError,
	{ params: DeleteTimeTickerParams },
	TContext
> => {
	const mutationKey = ["deleteTimeTicker"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof deleteTimeTicker>>,
		{ params: DeleteTimeTickerParams }
	> = (props) => {
		const { params } = props ?? {};

		return deleteTimeTicker(params, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type DeleteTimeTickerMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteTimeTicker>>
>;

export type DeleteTimeTickerMutationError = ErrorType<unknown>;

export const createDeleteTimeTicker = <TError = ErrorType<unknown>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof deleteTimeTicker>>,
			TError,
			{ params: DeleteTimeTickerParams },
			TContext
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof deleteTimeTicker>>,
	TError,
	{ params: DeleteTimeTickerParams },
	TContext
> => {
	return createMutation(() => ({
		...getDeleteTimeTickerMutationOptions(options?.()),
		queryClient,
	}));
};
export const getDeleteTimeTickersBatchUrl = () => {
	return `/api/time-ticker/delete-batch`;
};

export const deleteTimeTickersBatch = async (
	deleteTimeTickersBatchBody: string[],
	options?: RequestInit
): Promise<void> => {
	return customInstance<void>(getDeleteTimeTickersBatchUrl(), {
		...options,
		method: "DELETE",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(deleteTimeTickersBatchBody),
	});
};

export const getDeleteTimeTickersBatchMutationOptions = <
	TError = ErrorType<unknown>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof deleteTimeTickersBatch>>,
		TError,
		{ data: BodyType<string[]> },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof deleteTimeTickersBatch>>,
	TError,
	{ data: BodyType<string[]> },
	TContext
> => {
	const mutationKey = ["deleteTimeTickersBatch"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof deleteTimeTickersBatch>>,
		{ data: BodyType<string[]> }
	> = (props) => {
		const { data } = props ?? {};

		return deleteTimeTickersBatch(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type DeleteTimeTickersBatchMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteTimeTickersBatch>>
>;
export type DeleteTimeTickersBatchMutationBody = BodyType<string[]>;
export type DeleteTimeTickersBatchMutationError = ErrorType<unknown>;

export const createDeleteTimeTickersBatch = <TError = ErrorType<unknown>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof deleteTimeTickersBatch>>,
			TError,
			{ data: BodyType<string[]> },
			TContext
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof deleteTimeTickersBatch>>,
	TError,
	{ data: BodyType<string[]> },
	TContext
> => {
	return createMutation(() => ({
		...getDeleteTimeTickersBatchMutationOptions(options?.()),
		queryClient,
	}));
};
export const getGetCronTickersUrl = () => {
	return `/api/cron-tickers`;
};

export const getCronTickers = async (options?: RequestInit): Promise<void> => {
	return customInstance<void>(getGetCronTickersUrl(), {
		...options,
		method: "GET",
	});
};

export const getGetCronTickersQueryKey = () => {
	return [`/api/cron-tickers`] as const;
};

export const getGetCronTickersQueryOptions = <
	TData = Awaited<ReturnType<typeof getCronTickers>>,
	TError = ErrorType<unknown>,
>(options?: {
	query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof getCronTickers>>, TError, TData>>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetCronTickersQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getCronTickers>>> = () =>
		getCronTickers(requestOptions);

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof getCronTickers>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCronTickersQueryResult = NonNullable<Awaited<ReturnType<typeof getCronTickers>>>;
export type GetCronTickersQueryError = ErrorType<unknown>;

export function createGetCronTickers<
	TData = Awaited<ReturnType<typeof getCronTickers>>,
	TError = ErrorType<unknown>,
>(
	options?: () => {
		query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof getCronTickers>>, TError, TData>>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getGetCronTickersQueryOptions(options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}

export const getGetCronTickersPaginatedUrl = (params?: GetCronTickersPaginatedParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/api/cron-tickers/paginated?${stringifiedParams}`
		: `/api/cron-tickers/paginated`;
};

export const getCronTickersPaginated = async (
	params?: GetCronTickersPaginatedParams,
	options?: RequestInit
): Promise<void> => {
	return customInstance<void>(getGetCronTickersPaginatedUrl(params), {
		...options,
		method: "GET",
	});
};

export const getGetCronTickersPaginatedQueryKey = (params?: GetCronTickersPaginatedParams) => {
	return [`/api/cron-tickers/paginated`, ...(params ? [params] : [])] as const;
};

export const getGetCronTickersPaginatedQueryOptions = <
	TData = Awaited<ReturnType<typeof getCronTickersPaginated>>,
	TError = ErrorType<unknown>,
>(
	params?: GetCronTickersPaginatedParams,
	options?: {
		query?: Partial<
			CreateQueryOptions<Awaited<ReturnType<typeof getCronTickersPaginated>>, TError, TData>
		>;
		request?: SecondParameter<typeof customInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetCronTickersPaginatedQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getCronTickersPaginated>>> = () =>
		getCronTickersPaginated(params, requestOptions);

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof getCronTickersPaginated>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCronTickersPaginatedQueryResult = NonNullable<
	Awaited<ReturnType<typeof getCronTickersPaginated>>
>;
export type GetCronTickersPaginatedQueryError = ErrorType<unknown>;

export function createGetCronTickersPaginated<
	TData = Awaited<ReturnType<typeof getCronTickersPaginated>>,
	TError = ErrorType<unknown>,
>(
	params?: () => GetCronTickersPaginatedParams,
	options?: () => {
		query?: Partial<
			CreateQueryOptions<Awaited<ReturnType<typeof getCronTickersPaginated>>, TError, TData>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getGetCronTickersPaginatedQueryOptions(params?.(), options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}

export const getGetCronTickersGraphDataRangeUrl = (params?: GetCronTickersGraphDataRangeParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/api/cron-tickers/graph-data-range?${stringifiedParams}`
		: `/api/cron-tickers/graph-data-range`;
};

export const getCronTickersGraphDataRange = async (
	params?: GetCronTickersGraphDataRangeParams,
	options?: RequestInit
): Promise<void> => {
	return customInstance<void>(getGetCronTickersGraphDataRangeUrl(params), {
		...options,
		method: "GET",
	});
};

export const getGetCronTickersGraphDataRangeQueryKey = (
	params?: GetCronTickersGraphDataRangeParams
) => {
	return [`/api/cron-tickers/graph-data-range`, ...(params ? [params] : [])] as const;
};

export const getGetCronTickersGraphDataRangeQueryOptions = <
	TData = Awaited<ReturnType<typeof getCronTickersGraphDataRange>>,
	TError = ErrorType<unknown>,
>(
	params?: GetCronTickersGraphDataRangeParams,
	options?: {
		query?: Partial<
			CreateQueryOptions<Awaited<ReturnType<typeof getCronTickersGraphDataRange>>, TError, TData>
		>;
		request?: SecondParameter<typeof customInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetCronTickersGraphDataRangeQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getCronTickersGraphDataRange>>> = () =>
		getCronTickersGraphDataRange(params, requestOptions);

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof getCronTickersGraphDataRange>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCronTickersGraphDataRangeQueryResult = NonNullable<
	Awaited<ReturnType<typeof getCronTickersGraphDataRange>>
>;
export type GetCronTickersGraphDataRangeQueryError = ErrorType<unknown>;

export function createGetCronTickersGraphDataRange<
	TData = Awaited<ReturnType<typeof getCronTickersGraphDataRange>>,
	TError = ErrorType<unknown>,
>(
	params?: () => GetCronTickersGraphDataRangeParams,
	options?: () => {
		query?: Partial<
			CreateQueryOptions<Awaited<ReturnType<typeof getCronTickersGraphDataRange>>, TError, TData>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getGetCronTickersGraphDataRangeQueryOptions(params?.(), options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}

export const getGetCronTickersByIdGraphDataRangeUrl = (
	params: GetCronTickersByIdGraphDataRangeParams
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/api/cron-tickers/graph-data-range-id?${stringifiedParams}`
		: `/api/cron-tickers/graph-data-range-id`;
};

export const getCronTickersByIdGraphDataRange = async (
	params: GetCronTickersByIdGraphDataRangeParams,
	options?: RequestInit
): Promise<void> => {
	return customInstance<void>(getGetCronTickersByIdGraphDataRangeUrl(params), {
		...options,
		method: "GET",
	});
};

export const getGetCronTickersByIdGraphDataRangeQueryKey = (
	params?: GetCronTickersByIdGraphDataRangeParams
) => {
	return [`/api/cron-tickers/graph-data-range-id`, ...(params ? [params] : [])] as const;
};

export const getGetCronTickersByIdGraphDataRangeQueryOptions = <
	TData = Awaited<ReturnType<typeof getCronTickersByIdGraphDataRange>>,
	TError = ErrorType<unknown>,
>(
	params: GetCronTickersByIdGraphDataRangeParams,
	options?: {
		query?: Partial<
			CreateQueryOptions<
				Awaited<ReturnType<typeof getCronTickersByIdGraphDataRange>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetCronTickersByIdGraphDataRangeQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getCronTickersByIdGraphDataRange>>> = () =>
		getCronTickersByIdGraphDataRange(params, requestOptions);

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof getCronTickersByIdGraphDataRange>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCronTickersByIdGraphDataRangeQueryResult = NonNullable<
	Awaited<ReturnType<typeof getCronTickersByIdGraphDataRange>>
>;
export type GetCronTickersByIdGraphDataRangeQueryError = ErrorType<unknown>;

export function createGetCronTickersByIdGraphDataRange<
	TData = Awaited<ReturnType<typeof getCronTickersByIdGraphDataRange>>,
	TError = ErrorType<unknown>,
>(
	params: () => GetCronTickersByIdGraphDataRangeParams,
	options?: () => {
		query?: Partial<
			CreateQueryOptions<
				Awaited<ReturnType<typeof getCronTickersByIdGraphDataRange>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getGetCronTickersByIdGraphDataRangeQueryOptions(params(), options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}

export const getGetCronTickersGraphDataUrl = () => {
	return `/api/cron-tickers/graph-data`;
};

export const getCronTickersGraphData = async (options?: RequestInit): Promise<void> => {
	return customInstance<void>(getGetCronTickersGraphDataUrl(), {
		...options,
		method: "GET",
	});
};

export const getGetCronTickersGraphDataQueryKey = () => {
	return [`/api/cron-tickers/graph-data`] as const;
};

export const getGetCronTickersGraphDataQueryOptions = <
	TData = Awaited<ReturnType<typeof getCronTickersGraphData>>,
	TError = ErrorType<unknown>,
>(options?: {
	query?: Partial<
		CreateQueryOptions<Awaited<ReturnType<typeof getCronTickersGraphData>>, TError, TData>
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetCronTickersGraphDataQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getCronTickersGraphData>>> = () =>
		getCronTickersGraphData(requestOptions);

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof getCronTickersGraphData>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCronTickersGraphDataQueryResult = NonNullable<
	Awaited<ReturnType<typeof getCronTickersGraphData>>
>;
export type GetCronTickersGraphDataQueryError = ErrorType<unknown>;

export function createGetCronTickersGraphData<
	TData = Awaited<ReturnType<typeof getCronTickersGraphData>>,
	TError = ErrorType<unknown>,
>(
	options?: () => {
		query?: Partial<
			CreateQueryOptions<Awaited<ReturnType<typeof getCronTickersGraphData>>, TError, TData>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getGetCronTickersGraphDataQueryOptions(options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}

export const getGetCronTickerOccurrencesUrl = (cronTickerId: string) => {
	return `/api/cron-ticker-occurrences/${cronTickerId}`;
};

export const getCronTickerOccurrences = async (
	cronTickerId: string,
	options?: RequestInit
): Promise<void> => {
	return customInstance<void>(getGetCronTickerOccurrencesUrl(cronTickerId), {
		...options,
		method: "GET",
	});
};

export const getGetCronTickerOccurrencesQueryKey = (cronTickerId: string) => {
	return [`/api/cron-ticker-occurrences/${cronTickerId}`] as const;
};

export const getGetCronTickerOccurrencesQueryOptions = <
	TData = Awaited<ReturnType<typeof getCronTickerOccurrences>>,
	TError = ErrorType<unknown>,
>(
	cronTickerId: string,
	options?: {
		query?: Partial<
			CreateQueryOptions<Awaited<ReturnType<typeof getCronTickerOccurrences>>, TError, TData>
		>;
		request?: SecondParameter<typeof customInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetCronTickerOccurrencesQueryKey(cronTickerId);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getCronTickerOccurrences>>> = () =>
		getCronTickerOccurrences(cronTickerId, requestOptions);

	return { queryKey, queryFn, enabled: !!cronTickerId, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof getCronTickerOccurrences>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCronTickerOccurrencesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getCronTickerOccurrences>>
>;
export type GetCronTickerOccurrencesQueryError = ErrorType<unknown>;

export function createGetCronTickerOccurrences<
	TData = Awaited<ReturnType<typeof getCronTickerOccurrences>>,
	TError = ErrorType<unknown>,
>(
	cronTickerId: () => string,
	options?: () => {
		query?: Partial<
			CreateQueryOptions<Awaited<ReturnType<typeof getCronTickerOccurrences>>, TError, TData>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getGetCronTickerOccurrencesQueryOptions(cronTickerId(), options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}

export const getGetCronTickerOccurrencesPaginatedUrl = (
	cronTickerId: string,
	params?: GetCronTickerOccurrencesPaginatedParams
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/api/cron-ticker-occurrences/${cronTickerId}/paginated?${stringifiedParams}`
		: `/api/cron-ticker-occurrences/${cronTickerId}/paginated`;
};

export const getCronTickerOccurrencesPaginated = async (
	cronTickerId: string,
	params?: GetCronTickerOccurrencesPaginatedParams,
	options?: RequestInit
): Promise<void> => {
	return customInstance<void>(getGetCronTickerOccurrencesPaginatedUrl(cronTickerId, params), {
		...options,
		method: "GET",
	});
};

export const getGetCronTickerOccurrencesPaginatedQueryKey = (
	cronTickerId: string,
	params?: GetCronTickerOccurrencesPaginatedParams
) => {
	return [
		`/api/cron-ticker-occurrences/${cronTickerId}/paginated`,
		...(params ? [params] : []),
	] as const;
};

export const getGetCronTickerOccurrencesPaginatedQueryOptions = <
	TData = Awaited<ReturnType<typeof getCronTickerOccurrencesPaginated>>,
	TError = ErrorType<unknown>,
>(
	cronTickerId: string,
	params?: GetCronTickerOccurrencesPaginatedParams,
	options?: {
		query?: Partial<
			CreateQueryOptions<
				Awaited<ReturnType<typeof getCronTickerOccurrencesPaginated>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetCronTickerOccurrencesPaginatedQueryKey(cronTickerId, params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getCronTickerOccurrencesPaginated>>
	> = () => getCronTickerOccurrencesPaginated(cronTickerId, params, requestOptions);

	return { queryKey, queryFn, enabled: !!cronTickerId, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof getCronTickerOccurrencesPaginated>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCronTickerOccurrencesPaginatedQueryResult = NonNullable<
	Awaited<ReturnType<typeof getCronTickerOccurrencesPaginated>>
>;
export type GetCronTickerOccurrencesPaginatedQueryError = ErrorType<unknown>;

export function createGetCronTickerOccurrencesPaginated<
	TData = Awaited<ReturnType<typeof getCronTickerOccurrencesPaginated>>,
	TError = ErrorType<unknown>,
>(
	cronTickerId: () => string,
	params?: () => GetCronTickerOccurrencesPaginatedParams,
	options?: () => {
		query?: Partial<
			CreateQueryOptions<
				Awaited<ReturnType<typeof getCronTickerOccurrencesPaginated>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getGetCronTickerOccurrencesPaginatedQueryOptions(cronTickerId(), params?.(), options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}

export const getGetCronTickerOccurrencesGraphDataUrl = (cronTickerId: string) => {
	return `/api/cron-ticker-occurrences/${cronTickerId}/graph-data`;
};

export const getCronTickerOccurrencesGraphData = async (
	cronTickerId: string,
	options?: RequestInit
): Promise<void> => {
	return customInstance<void>(getGetCronTickerOccurrencesGraphDataUrl(cronTickerId), {
		...options,
		method: "GET",
	});
};

export const getGetCronTickerOccurrencesGraphDataQueryKey = (cronTickerId: string) => {
	return [`/api/cron-ticker-occurrences/${cronTickerId}/graph-data`] as const;
};

export const getGetCronTickerOccurrencesGraphDataQueryOptions = <
	TData = Awaited<ReturnType<typeof getCronTickerOccurrencesGraphData>>,
	TError = ErrorType<unknown>,
>(
	cronTickerId: string,
	options?: {
		query?: Partial<
			CreateQueryOptions<
				Awaited<ReturnType<typeof getCronTickerOccurrencesGraphData>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetCronTickerOccurrencesGraphDataQueryKey(cronTickerId);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getCronTickerOccurrencesGraphData>>
	> = () => getCronTickerOccurrencesGraphData(cronTickerId, requestOptions);

	return { queryKey, queryFn, enabled: !!cronTickerId, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof getCronTickerOccurrencesGraphData>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCronTickerOccurrencesGraphDataQueryResult = NonNullable<
	Awaited<ReturnType<typeof getCronTickerOccurrencesGraphData>>
>;
export type GetCronTickerOccurrencesGraphDataQueryError = ErrorType<unknown>;

export function createGetCronTickerOccurrencesGraphData<
	TData = Awaited<ReturnType<typeof getCronTickerOccurrencesGraphData>>,
	TError = ErrorType<unknown>,
>(
	cronTickerId: () => string,
	options?: () => {
		query?: Partial<
			CreateQueryOptions<
				Awaited<ReturnType<typeof getCronTickerOccurrencesGraphData>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getGetCronTickerOccurrencesGraphDataQueryOptions(cronTickerId(), options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}

export const getAddCronTickerUrl = () => {
	return `/api/cron-ticker/add`;
};

export const addCronTicker = async (options?: RequestInit): Promise<void> => {
	return customInstance<void>(getAddCronTickerUrl(), {
		...options,
		method: "POST",
	});
};

export const getAddCronTickerMutationOptions = <
	TError = ErrorType<unknown>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof addCronTicker>>,
		TError,
		void,
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationOptions<Awaited<ReturnType<typeof addCronTicker>>, TError, void, TContext> => {
	const mutationKey = ["addCronTicker"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<Awaited<ReturnType<typeof addCronTicker>>, void> = () => {
		return addCronTicker(requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type AddCronTickerMutationResult = NonNullable<Awaited<ReturnType<typeof addCronTicker>>>;

export type AddCronTickerMutationError = ErrorType<unknown>;

export const createAddCronTicker = <TError = ErrorType<unknown>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof addCronTicker>>,
			TError,
			void,
			TContext
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<Awaited<ReturnType<typeof addCronTicker>>, TError, void, TContext> => {
	return createMutation(() => ({ ...getAddCronTickerMutationOptions(options?.()), queryClient }));
};
export const getUpdateCronTickerUrl = (params: UpdateCronTickerParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/api/cron-ticker/update?${stringifiedParams}`
		: `/api/cron-ticker/update`;
};

export const updateCronTicker = async (
	params: UpdateCronTickerParams,
	options?: RequestInit
): Promise<void> => {
	return customInstance<void>(getUpdateCronTickerUrl(params), {
		...options,
		method: "PUT",
	});
};

export const getUpdateCronTickerMutationOptions = <
	TError = ErrorType<unknown>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof updateCronTicker>>,
		TError,
		{ params: UpdateCronTickerParams },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof updateCronTicker>>,
	TError,
	{ params: UpdateCronTickerParams },
	TContext
> => {
	const mutationKey = ["updateCronTicker"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof updateCronTicker>>,
		{ params: UpdateCronTickerParams }
	> = (props) => {
		const { params } = props ?? {};

		return updateCronTicker(params, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type UpdateCronTickerMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateCronTicker>>
>;

export type UpdateCronTickerMutationError = ErrorType<unknown>;

export const createUpdateCronTicker = <TError = ErrorType<unknown>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof updateCronTicker>>,
			TError,
			{ params: UpdateCronTickerParams },
			TContext
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof updateCronTicker>>,
	TError,
	{ params: UpdateCronTickerParams },
	TContext
> => {
	return createMutation(() => ({
		...getUpdateCronTickerMutationOptions(options?.()),
		queryClient,
	}));
};
export const getRunCronTickerOnDemandUrl = (params: RunCronTickerOnDemandParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/api/cron-ticker/run?${stringifiedParams}`
		: `/api/cron-ticker/run`;
};

export const runCronTickerOnDemand = async (
	params: RunCronTickerOnDemandParams,
	options?: RequestInit
): Promise<void> => {
	return customInstance<void>(getRunCronTickerOnDemandUrl(params), {
		...options,
		method: "POST",
	});
};

export const getRunCronTickerOnDemandMutationOptions = <
	TError = ErrorType<unknown>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof runCronTickerOnDemand>>,
		TError,
		{ params: RunCronTickerOnDemandParams },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof runCronTickerOnDemand>>,
	TError,
	{ params: RunCronTickerOnDemandParams },
	TContext
> => {
	const mutationKey = ["runCronTickerOnDemand"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof runCronTickerOnDemand>>,
		{ params: RunCronTickerOnDemandParams }
	> = (props) => {
		const { params } = props ?? {};

		return runCronTickerOnDemand(params, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type RunCronTickerOnDemandMutationResult = NonNullable<
	Awaited<ReturnType<typeof runCronTickerOnDemand>>
>;

export type RunCronTickerOnDemandMutationError = ErrorType<unknown>;

export const createRunCronTickerOnDemand = <TError = ErrorType<unknown>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof runCronTickerOnDemand>>,
			TError,
			{ params: RunCronTickerOnDemandParams },
			TContext
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof runCronTickerOnDemand>>,
	TError,
	{ params: RunCronTickerOnDemandParams },
	TContext
> => {
	return createMutation(() => ({
		...getRunCronTickerOnDemandMutationOptions(options?.()),
		queryClient,
	}));
};
export const getDeleteCronTickerUrl = (params: DeleteCronTickerParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/api/cron-ticker/delete?${stringifiedParams}`
		: `/api/cron-ticker/delete`;
};

export const deleteCronTicker = async (
	params: DeleteCronTickerParams,
	options?: RequestInit
): Promise<void> => {
	return customInstance<void>(getDeleteCronTickerUrl(params), {
		...options,
		method: "DELETE",
	});
};

export const getDeleteCronTickerMutationOptions = <
	TError = ErrorType<unknown>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof deleteCronTicker>>,
		TError,
		{ params: DeleteCronTickerParams },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof deleteCronTicker>>,
	TError,
	{ params: DeleteCronTickerParams },
	TContext
> => {
	const mutationKey = ["deleteCronTicker"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof deleteCronTicker>>,
		{ params: DeleteCronTickerParams }
	> = (props) => {
		const { params } = props ?? {};

		return deleteCronTicker(params, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type DeleteCronTickerMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteCronTicker>>
>;

export type DeleteCronTickerMutationError = ErrorType<unknown>;

export const createDeleteCronTicker = <TError = ErrorType<unknown>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof deleteCronTicker>>,
			TError,
			{ params: DeleteCronTickerParams },
			TContext
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof deleteCronTicker>>,
	TError,
	{ params: DeleteCronTickerParams },
	TContext
> => {
	return createMutation(() => ({
		...getDeleteCronTickerMutationOptions(options?.()),
		queryClient,
	}));
};
export const getDeleteCronTickerOccurrenceUrl = (params: DeleteCronTickerOccurrenceParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/api/cron-ticker-occurrence/delete?${stringifiedParams}`
		: `/api/cron-ticker-occurrence/delete`;
};

export const deleteCronTickerOccurrence = async (
	params: DeleteCronTickerOccurrenceParams,
	options?: RequestInit
): Promise<void> => {
	return customInstance<void>(getDeleteCronTickerOccurrenceUrl(params), {
		...options,
		method: "DELETE",
	});
};

export const getDeleteCronTickerOccurrenceMutationOptions = <
	TError = ErrorType<unknown>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof deleteCronTickerOccurrence>>,
		TError,
		{ params: DeleteCronTickerOccurrenceParams },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof deleteCronTickerOccurrence>>,
	TError,
	{ params: DeleteCronTickerOccurrenceParams },
	TContext
> => {
	const mutationKey = ["deleteCronTickerOccurrence"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof deleteCronTickerOccurrence>>,
		{ params: DeleteCronTickerOccurrenceParams }
	> = (props) => {
		const { params } = props ?? {};

		return deleteCronTickerOccurrence(params, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type DeleteCronTickerOccurrenceMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteCronTickerOccurrence>>
>;

export type DeleteCronTickerOccurrenceMutationError = ErrorType<unknown>;

export const createDeleteCronTickerOccurrence = <TError = ErrorType<unknown>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof deleteCronTickerOccurrence>>,
			TError,
			{ params: DeleteCronTickerOccurrenceParams },
			TContext
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof deleteCronTickerOccurrence>>,
	TError,
	{ params: DeleteCronTickerOccurrenceParams },
	TContext
> => {
	return createMutation(() => ({
		...getDeleteCronTickerOccurrenceMutationOptions(options?.()),
		queryClient,
	}));
};
export const getCancelTickerUrl = (params: CancelTickerParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/api/ticker/cancel?${stringifiedParams}`
		: `/api/ticker/cancel`;
};

export const cancelTicker = async (
	params: CancelTickerParams,
	options?: RequestInit
): Promise<void> => {
	return customInstance<void>(getCancelTickerUrl(params), {
		...options,
		method: "POST",
	});
};

export const getCancelTickerMutationOptions = <
	TError = ErrorType<unknown>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof cancelTicker>>,
		TError,
		{ params: CancelTickerParams },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof cancelTicker>>,
	TError,
	{ params: CancelTickerParams },
	TContext
> => {
	const mutationKey = ["cancelTicker"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof cancelTicker>>,
		{ params: CancelTickerParams }
	> = (props) => {
		const { params } = props ?? {};

		return cancelTicker(params, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CancelTickerMutationResult = NonNullable<Awaited<ReturnType<typeof cancelTicker>>>;

export type CancelTickerMutationError = ErrorType<unknown>;

export const createCancelTicker = <TError = ErrorType<unknown>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof cancelTicker>>,
			TError,
			{ params: CancelTickerParams },
			TContext
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof cancelTicker>>,
	TError,
	{ params: CancelTickerParams },
	TContext
> => {
	return createMutation(() => ({ ...getCancelTickerMutationOptions(options?.()), queryClient }));
};
export const getGetTickerRequestUrl = (params: GetTickerRequestParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/api/ticker-request?${stringifiedParams}`
		: `/api/ticker-request`;
};

export const getTickerRequest = async (
	params: GetTickerRequestParams,
	options?: RequestInit
): Promise<void> => {
	return customInstance<void>(getGetTickerRequestUrl(params), {
		...options,
		method: "GET",
	});
};

export const getGetTickerRequestQueryKey = (params?: GetTickerRequestParams) => {
	return [`/api/ticker-request`, ...(params ? [params] : [])] as const;
};

export const getGetTickerRequestQueryOptions = <
	TData = Awaited<ReturnType<typeof getTickerRequest>>,
	TError = ErrorType<unknown>,
>(
	params: GetTickerRequestParams,
	options?: {
		query?: Partial<
			CreateQueryOptions<Awaited<ReturnType<typeof getTickerRequest>>, TError, TData>
		>;
		request?: SecondParameter<typeof customInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetTickerRequestQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getTickerRequest>>> = () =>
		getTickerRequest(params, requestOptions);

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof getTickerRequest>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTickerRequestQueryResult = NonNullable<Awaited<ReturnType<typeof getTickerRequest>>>;
export type GetTickerRequestQueryError = ErrorType<unknown>;

export function createGetTickerRequest<
	TData = Awaited<ReturnType<typeof getTickerRequest>>,
	TError = ErrorType<unknown>,
>(
	params: () => GetTickerRequestParams,
	options?: () => {
		query?: Partial<
			CreateQueryOptions<Awaited<ReturnType<typeof getTickerRequest>>, TError, TData>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getGetTickerRequestQueryOptions(params(), options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}

export const getGetTickerFunctionsUrl = () => {
	return `/api/ticker-functions`;
};

export const getTickerFunctions = async (options?: RequestInit): Promise<void> => {
	return customInstance<void>(getGetTickerFunctionsUrl(), {
		...options,
		method: "GET",
	});
};

export const getGetTickerFunctionsQueryKey = () => {
	return [`/api/ticker-functions`] as const;
};

export const getGetTickerFunctionsQueryOptions = <
	TData = Awaited<ReturnType<typeof getTickerFunctions>>,
	TError = ErrorType<unknown>,
>(options?: {
	query?: Partial<
		CreateQueryOptions<Awaited<ReturnType<typeof getTickerFunctions>>, TError, TData>
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetTickerFunctionsQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getTickerFunctions>>> = () =>
		getTickerFunctions(requestOptions);

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof getTickerFunctions>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTickerFunctionsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getTickerFunctions>>
>;
export type GetTickerFunctionsQueryError = ErrorType<unknown>;

export function createGetTickerFunctions<
	TData = Awaited<ReturnType<typeof getTickerFunctions>>,
	TError = ErrorType<unknown>,
>(
	options?: () => {
		query?: Partial<
			CreateQueryOptions<Awaited<ReturnType<typeof getTickerFunctions>>, TError, TData>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getGetTickerFunctionsQueryOptions(options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}

export const getGetNextTickerUrl = () => {
	return `/api/ticker-host/next-ticker`;
};

export const getNextTicker = async (options?: RequestInit): Promise<void> => {
	return customInstance<void>(getGetNextTickerUrl(), {
		...options,
		method: "GET",
	});
};

export const getGetNextTickerQueryKey = () => {
	return [`/api/ticker-host/next-ticker`] as const;
};

export const getGetNextTickerQueryOptions = <
	TData = Awaited<ReturnType<typeof getNextTicker>>,
	TError = ErrorType<unknown>,
>(options?: {
	query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof getNextTicker>>, TError, TData>>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetNextTickerQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getNextTicker>>> = () =>
		getNextTicker(requestOptions);

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof getNextTicker>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetNextTickerQueryResult = NonNullable<Awaited<ReturnType<typeof getNextTicker>>>;
export type GetNextTickerQueryError = ErrorType<unknown>;

export function createGetNextTicker<
	TData = Awaited<ReturnType<typeof getNextTicker>>,
	TError = ErrorType<unknown>,
>(
	options?: () => {
		query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof getNextTicker>>, TError, TData>>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getGetNextTickerQueryOptions(options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}

export const getStopTickerHostUrl = () => {
	return `/api/ticker-host/stop`;
};

export const stopTickerHost = async (options?: RequestInit): Promise<void> => {
	return customInstance<void>(getStopTickerHostUrl(), {
		...options,
		method: "POST",
	});
};

export const getStopTickerHostMutationOptions = <
	TError = ErrorType<unknown>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof stopTickerHost>>,
		TError,
		void,
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationOptions<Awaited<ReturnType<typeof stopTickerHost>>, TError, void, TContext> => {
	const mutationKey = ["stopTickerHost"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<Awaited<ReturnType<typeof stopTickerHost>>, void> = () => {
		return stopTickerHost(requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type StopTickerHostMutationResult = NonNullable<Awaited<ReturnType<typeof stopTickerHost>>>;

export type StopTickerHostMutationError = ErrorType<unknown>;

export const createStopTickerHost = <TError = ErrorType<unknown>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof stopTickerHost>>,
			TError,
			void,
			TContext
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<Awaited<ReturnType<typeof stopTickerHost>>, TError, void, TContext> => {
	return createMutation(() => ({ ...getStopTickerHostMutationOptions(options?.()), queryClient }));
};
export const getStartTickerHostUrl = () => {
	return `/api/ticker-host/start`;
};

export const startTickerHost = async (options?: RequestInit): Promise<void> => {
	return customInstance<void>(getStartTickerHostUrl(), {
		...options,
		method: "POST",
	});
};

export const getStartTickerHostMutationOptions = <
	TError = ErrorType<unknown>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof startTickerHost>>,
		TError,
		void,
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationOptions<Awaited<ReturnType<typeof startTickerHost>>, TError, void, TContext> => {
	const mutationKey = ["startTickerHost"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<Awaited<ReturnType<typeof startTickerHost>>, void> = () => {
		return startTickerHost(requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type StartTickerHostMutationResult = NonNullable<
	Awaited<ReturnType<typeof startTickerHost>>
>;

export type StartTickerHostMutationError = ErrorType<unknown>;

export const createStartTickerHost = <TError = ErrorType<unknown>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof startTickerHost>>,
			TError,
			void,
			TContext
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<Awaited<ReturnType<typeof startTickerHost>>, TError, void, TContext> => {
	return createMutation(() => ({ ...getStartTickerHostMutationOptions(options?.()), queryClient }));
};
export const getRestartTickerHostUrl = () => {
	return `/api/ticker-host/restart`;
};

export const restartTickerHost = async (options?: RequestInit): Promise<void> => {
	return customInstance<void>(getRestartTickerHostUrl(), {
		...options,
		method: "POST",
	});
};

export const getRestartTickerHostMutationOptions = <
	TError = ErrorType<unknown>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof restartTickerHost>>,
		TError,
		void,
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof restartTickerHost>>,
	TError,
	void,
	TContext
> => {
	const mutationKey = ["restartTickerHost"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<Awaited<ReturnType<typeof restartTickerHost>>, void> = () => {
		return restartTickerHost(requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type RestartTickerHostMutationResult = NonNullable<
	Awaited<ReturnType<typeof restartTickerHost>>
>;

export type RestartTickerHostMutationError = ErrorType<unknown>;

export const createRestartTickerHost = <TError = ErrorType<unknown>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof restartTickerHost>>,
			TError,
			void,
			TContext
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<Awaited<ReturnType<typeof restartTickerHost>>, TError, void, TContext> => {
	return createMutation(() => ({
		...getRestartTickerHostMutationOptions(options?.()),
		queryClient,
	}));
};
export const getGetTickerHostStatusUrl = () => {
	return `/api/ticker-host/status`;
};

export const getTickerHostStatus = async (options?: RequestInit): Promise<void> => {
	return customInstance<void>(getGetTickerHostStatusUrl(), {
		...options,
		method: "GET",
	});
};

export const getGetTickerHostStatusQueryKey = () => {
	return [`/api/ticker-host/status`] as const;
};

export const getGetTickerHostStatusQueryOptions = <
	TData = Awaited<ReturnType<typeof getTickerHostStatus>>,
	TError = ErrorType<unknown>,
>(options?: {
	query?: Partial<
		CreateQueryOptions<Awaited<ReturnType<typeof getTickerHostStatus>>, TError, TData>
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetTickerHostStatusQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getTickerHostStatus>>> = () =>
		getTickerHostStatus(requestOptions);

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof getTickerHostStatus>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTickerHostStatusQueryResult = NonNullable<
	Awaited<ReturnType<typeof getTickerHostStatus>>
>;
export type GetTickerHostStatusQueryError = ErrorType<unknown>;

export function createGetTickerHostStatus<
	TData = Awaited<ReturnType<typeof getTickerHostStatus>>,
	TError = ErrorType<unknown>,
>(
	options?: () => {
		query?: Partial<
			CreateQueryOptions<Awaited<ReturnType<typeof getTickerHostStatus>>, TError, TData>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getGetTickerHostStatusQueryOptions(options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}

export const getGetLastWeekJobStatusUrl = () => {
	return `/api/ticker/statuses/get-last-week`;
};

export const getLastWeekJobStatus = async (options?: RequestInit): Promise<void> => {
	return customInstance<void>(getGetLastWeekJobStatusUrl(), {
		...options,
		method: "GET",
	});
};

export const getGetLastWeekJobStatusQueryKey = () => {
	return [`/api/ticker/statuses/get-last-week`] as const;
};

export const getGetLastWeekJobStatusQueryOptions = <
	TData = Awaited<ReturnType<typeof getLastWeekJobStatus>>,
	TError = ErrorType<unknown>,
>(options?: {
	query?: Partial<
		CreateQueryOptions<Awaited<ReturnType<typeof getLastWeekJobStatus>>, TError, TData>
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetLastWeekJobStatusQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getLastWeekJobStatus>>> = () =>
		getLastWeekJobStatus(requestOptions);

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof getLastWeekJobStatus>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetLastWeekJobStatusQueryResult = NonNullable<
	Awaited<ReturnType<typeof getLastWeekJobStatus>>
>;
export type GetLastWeekJobStatusQueryError = ErrorType<unknown>;

export function createGetLastWeekJobStatus<
	TData = Awaited<ReturnType<typeof getLastWeekJobStatus>>,
	TError = ErrorType<unknown>,
>(
	options?: () => {
		query?: Partial<
			CreateQueryOptions<Awaited<ReturnType<typeof getLastWeekJobStatus>>, TError, TData>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getGetLastWeekJobStatusQueryOptions(options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}

export const getGetJobStatusesUrl = () => {
	return `/api/ticker/statuses/get`;
};

export const getJobStatuses = async (options?: RequestInit): Promise<void> => {
	return customInstance<void>(getGetJobStatusesUrl(), {
		...options,
		method: "GET",
	});
};

export const getGetJobStatusesQueryKey = () => {
	return [`/api/ticker/statuses/get`] as const;
};

export const getGetJobStatusesQueryOptions = <
	TData = Awaited<ReturnType<typeof getJobStatuses>>,
	TError = ErrorType<unknown>,
>(options?: {
	query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof getJobStatuses>>, TError, TData>>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetJobStatusesQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getJobStatuses>>> = () =>
		getJobStatuses(requestOptions);

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof getJobStatuses>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetJobStatusesQueryResult = NonNullable<Awaited<ReturnType<typeof getJobStatuses>>>;
export type GetJobStatusesQueryError = ErrorType<unknown>;

export function createGetJobStatuses<
	TData = Awaited<ReturnType<typeof getJobStatuses>>,
	TError = ErrorType<unknown>,
>(
	options?: () => {
		query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof getJobStatuses>>, TError, TData>>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getGetJobStatusesQueryOptions(options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}

export const getGetMachineJobsUrl = () => {
	return `/api/ticker/machine/jobs`;
};

export const getMachineJobs = async (options?: RequestInit): Promise<void> => {
	return customInstance<void>(getGetMachineJobsUrl(), {
		...options,
		method: "GET",
	});
};

export const getGetMachineJobsQueryKey = () => {
	return [`/api/ticker/machine/jobs`] as const;
};

export const getGetMachineJobsQueryOptions = <
	TData = Awaited<ReturnType<typeof getMachineJobs>>,
	TError = ErrorType<unknown>,
>(options?: {
	query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof getMachineJobs>>, TError, TData>>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetMachineJobsQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getMachineJobs>>> = () =>
		getMachineJobs(requestOptions);

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof getMachineJobs>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMachineJobsQueryResult = NonNullable<Awaited<ReturnType<typeof getMachineJobs>>>;
export type GetMachineJobsQueryError = ErrorType<unknown>;

export function createGetMachineJobs<
	TData = Awaited<ReturnType<typeof getMachineJobs>>,
	TError = ErrorType<unknown>,
>(
	options?: () => {
		query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof getMachineJobs>>, TError, TData>>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getGetMachineJobsQueryOptions(options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}
